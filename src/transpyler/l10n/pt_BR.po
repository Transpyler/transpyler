#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: fabiomacedomendes@gmail.com\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: Fábio Mendes <fabiomacedomendes@gmail.com>\n"
"Language-Team: \n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 2.0.1\n"

#. concatenate.name
msgid "concatenate"
msgstr ""
"concatenar\n"
"concatene"

#. concatenate.doc
msgid ""
"Convert argument to string and concatenate.\n"
"\n"
"If only one argument is passed, assumes it is a sequence.\n"
"\n"
"Examples:\n"
"    >>> concatenate('x = ', 2)\n"
"    'x = 2'\n"
"    >>> concatenate([1, 2, 3, 4])\n"
"    '1234'"
msgstr ""
"Converte argumentos para string e concatena.\n"
"\n"
"Se somente um argumento for passado, o mesmo é tratado como uma sequência.\n"
"\n"
"Examples:\n"
"    >>> concatenar('x = ', 2)\n"
"    'x = 2'\n"
"    >>> concatenar([1, 2, 3, 4])\n"
"    '1234'"

#. concatenate.args
#. show.args
#. alert.args
msgid "args"
msgstr "args"

#. join.name
#. String:join
msgid "join"
msgstr ""
"juntar\n"
"junte"

#. join.doc
msgid ""
"Similar to concatenate(), but takes an extra separator as first argument\n"
"argument.\n"
"\n"
"Examples:\n"
"    >>> join(', ', 1, 2, 3)\n"
"    '1, 2, 3'"
msgstr ""
"Semelhante à concatenar(), mas também recebe um separador extra como argumento.\n"
"\n"
"Examples:\n"
"    >>> juntar(', ', 1, 2, 3)\n"
"    '1, 2, 3'"

#. join.args
msgid "separator, args"
msgstr "separador, args"

#. format_string.name
msgid "format_string"
msgstr ""
"formatar\n"
"formate"

#. format_string.doc
msgid ""
"Format text inserting parameters in the wildcard positions.\n"
"\n"
"There are two different syntax for string formatting. The first is based\n"
"on C and uses symbols such as %s, %f, %d to delimit insertion points.\n"
"\n"
">>> format_string('%i != %.2f', 42, 43)\n"
"'42 != 43.00'\n"
"\n"
"The second uses curly braces.\n"
"\n"
">>> format_string('{0} != {1}', 42, 43)\n"
"'42 != 43'"
msgstr ""
"Formata o texto inserindo os parâmetros dados nas posições coringa.\n"
"\n"
"Existem duas sintaxes diferentes para a formatação de texto. A primeira,\n"
"baseada em C, utiliza o símbolo %s, %f, %d, etc para delimitar os pontos\n"
"de inserção por posição.\n"
"\n"
">>> formatar('%i = %.2f', 42, 42)\n"
"'42 = 42.00'\n"
"\n"
"A segunda usa esta sintaxe (explicar!)\n"
"\n"
">>> formatar('{0} = {1}', 42, 42)\n"
"'42 = 42'"

#. format_string.args
msgid "string, args, kwargs"
msgstr "texto, args, kwargs"

#. show.name
msgid "show"
msgstr ""
"mostrar\n"
"mostre"

#. show.doc
msgid ""
"Shows the object or text provided on the screen.\n"
"\n"
"If called with multiple arguments, prints them in sequence, separating\n"
"them with a white space.\n"
"\n"
"Examples:\n"
"    >>> show(\"Hello world!\")\n"
"    Hello World!"
msgstr ""
"Mostra o objeto ou texto fornecido na tela.\n"
"\n"
"Se chamado com vários argumentos, imprime-os em sequência, separando-os com um espaço em branco.\n"
"\n"
"Exemplos:\n"
"    >>> mostrar(\"Olá mundo!\")\n"
"    Olá Mundo!"

#. alert.name
msgid "alert"
msgstr "alerta"

#. alert.doc
msgid ""
"Similar to the `show` function, but displays the resulting message in a\n"
"dialog box."
msgstr "Semelhante à função `mostrar`, mas exibe a mensagem resultante em uma caixa de diálogo."

#. fshow.name
msgid "fshow"
msgstr ""
"mostrar_formatado\n"
"mostre_formatado"

#. fshow.doc
msgid "Displays a string after applying the provided formatting arguments."
msgstr "Exibe uma sequência depois de aplicar os argumentos de formatação fornecidos."

#. fshow.args
msgid "text, args, kwargs"
msgstr "texto, args, kwargs"

#. read_text.name
msgid "read_text"
msgstr ""
"ler_texto\n"
"leia_texto"

#. read_text.doc
msgid ""
"Prompts the user for a text entry.\n"
"\n"
"Examples:\n"
"    >>> name = read_text('Your name:')\n"
"    >>> show(\"Hello,\" + name)  # the user types \"Maria\"\n"
"    Hello Maria"
msgstr ""
"Solicita ao usuário uma entrada de texto.\n"
"\n"
"Exemplos:\n"
"    >>> nome = leia_texto('Seu nome:')\n"
"    >>> mostre(\"Olá,\" + nome)  # o usuário digita \"Maria\"\n"
"    Olá Maria"

#. read_text.args
msgid "message"
msgstr "mensagem"

#. read_number.name
msgid "read_number"
msgstr ""
"ler_número\n"
"leia_número"

#. read_number.doc
msgid ""
"Prompts the user for a numeric entry.\n"
"\n"
"Examples:\n"
"    >>> x = read_number('A number:')  # user types 2...\n"
"    >>> x + 40\n"
"    42"
msgstr ""
"Solicita ao usuário uma entrada numérica.\n"
"\n"
"Exemplos:\n"
"    >>> x = leia_número('A number:')  # usuário digita 2\n"
"    >>> x + 40\n"
"    42"

#. read_number.args
msgid "message, text, num"
msgstr "mensagem, texto, num"

#. read_file.name
msgid "read_file"
msgstr ""
"ler_arquivo\n"
"leia_arquivo"

#. read_file.doc
msgid ""
"Reads the content from a text file and returns it as string.\n"
"\n"
"Examples:\n"
"    >>> data = read_file(\"foo.txt\")"
msgstr ""
"Lê o conteúdo de um arquivo de texto e o retorna como sequência de caracteres.\n"
"\n"
"Exemplos:\n"
"    >>> data = leia_arquivo(\"foo.txt\")"

#. read_file.args
msgid "file"
msgstr "arquivo"

#. save_in_file.name
msgid "save_in_file"
msgstr ""
"salvar_em_arquivo\n"
"salve_em_arquivo"

#. save_in_file.doc
msgid ""
"Saves the text content to the indicated file, deleting any previous content.\n"
"\n"
"WARNING! If the given file exists, this function will overwrite your\n"
"content without asking!\n"
"\n"
"Examples:\n"
"    >>> save_in_file(data, \"foo.txt\")"
msgstr ""
"Salva o conteúdo de texto no arquivo indicado, excluindo qualquer conteúdo anterior.\n"
"\n"
"ATENÇÃO! Se o arquivo existir, esta função substituirá seu conteúdo sem avisar!\n"
"\n"
"Examples:\n"
"    >>> salvar_em_arquivo(dados, \"foo.txt\")"

#. save_in_file.args
msgid "text, file, F"
msgstr "texto, arquivo, F"

#. pause.name
msgid "pause"
msgstr ""
"pausar\n"
"pause\n"
"pausa"

#. pause.doc
msgid "Stops execution until the user presses the <return> key."
msgstr "Interrompe a execução até que o usuário pressione a tecla <enter>."

#. sleep.name
msgid "sleep"
msgstr "dormir"

#. sleep.doc
#, fuzzy
msgid ""
"sleep(seconds)\n"
"\n"
"Delay execution for a given number of seconds.  The argument may be\n"
"a floating point number for subsecond precision."
msgstr ""
"Dormir (segundos)\n"
"\n"
"Atrasa a execução por um dado número de segundos. O argumento pode ser um número de ponto flutuante para a precisão do subsegundo."

#. exit
msgid "exit"
msgstr ""
"sair\n"
"saia"

#. integer.name
msgid "int"
msgstr "inteiro"

#. integer.doc
#, fuzzy
msgid ""
"int(x=0) -> integer\n"
"int(x, base=10) -> integer\n"
"\n"
"Convert a number or string to an integer, or return 0 if no arguments\n"
"are given.  If x is a number, return x.__int__().  For floating point\n"
"numbers, this truncates towards zero.\n"
"\n"
"If x is not a number or if base is given, then x must be a string,\n"
"bytes, or bytearray instance representing an integer literal in the\n"
"given base.  The literal can be preceded by '+' or '-' and be surrounded\n"
"by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n"
"Base 0 means to interpret the base from the string as an integer literal.\n"
">>> int('0b100', base=0)\n"
"4"
msgstr ""
"Int (x = 0) -> integer int (x, base = 10) -> inteiro\n"
"\n"
"Converter um número ou seqüência de caracteres para um inteiro, ou retornar 0 se nenhum argumento for dado. Se x for um número, devolva x .__ int __ (). Para números de ponto flutuante, isto trunca para zero.\n"
"\n"
"Se x não é um número ou se base é dada, então x deve ser uma seqüência de caracteres, bytes ou bytearray instância representando um literal inteiro na base dada. O literal pode ser precedido por '+' ou '-' e ser cercado por espaços em branco. A base padrão é 10. As bases válidas são 0 e 2-36. Base 0 significa interpretar a base da string como um literal inteiro. >>> int ('0b100', base = 0) 4"

#. integer:bit_length
#. boolean:bit_length
#, fuzzy
msgid "bit_length"
msgstr "Comprimento de bit"

#. integer:conjugate
#. real:conjugate
#. complex:conjugate
#. boolean:conjugate
msgid "conjugate"
msgstr "conjugado"

#. integer:denominator
#. boolean:denominator
msgid "denominator"
msgstr "denominador"

#. integer:from_bytes
#. boolean:from_bytes
msgid "from_bytes"
msgstr "de_bytes"

#. integer:imag
#. real:imag
#. complex:imag
#. boolean:imag
msgid "imag"
msgstr "imaginário"

#. integer:numerator
#. boolean:numerator
msgid "numerator"
msgstr "numerador"

#. integer:real
#. real:real
#. complex:real
#. boolean:real
msgid "real"
msgstr "real"

#. integer:to_bytes
#. boolean:to_bytes
msgid "to_bytes"
msgstr "para_bytes"

#. real.name
msgid "float"
msgstr "real"

#. real.doc
#, fuzzy
msgid ""
"float(x) -> floating point number\n"
"\n"
"Convert a string or number to a floating point number, if possible."
msgstr ""
"Float (x) -> número de ponto flutuante\n"
"\n"
"Converta uma seqüência de caracteres ou número para um número de ponto flutuante, se possível."

#. real:as_integer_ratio
msgid "as_integer_ratio"
msgstr "razão_de_inteiros"

#. real:fromhex
msgid "fromhex"
msgstr "de_hexadecimal"

#. real:hex
#. hexadecimal.name
msgid "hex"
msgstr "hexadecimal"

#. real:is_integer
msgid "is_integer"
msgstr "é_inteiro"

#. complex.name
msgid "complex"
msgstr "complexo"

#. complex.doc
msgid ""
"complex(real[, imag]) -> complex number\n"
"\n"
"Create a complex number from a real part and an optional imaginary part.\n"
"This is equivalent to (real + imag*1j) where imag defaults to 0."
msgstr ""
"Complexo (real [, imag]) -> número complexo\n"
"\n"
"Crie um número complexo a partir de uma parte real e uma parte imaginária opcional. Equivalente a (real + imag * 1j) em que imag assume o valor padrão de 0."

#. boolean.name
msgid "bool"
msgstr ""
"booleano\n"
"lógico"

#. boolean.doc
#. verdadeiro.doc
#. Verdadeiro.doc
#. falso.doc
#. Falso.doc
msgid ""
"bool(x) -> bool\n"
"\n"
"Returns True when the argument x is true, False otherwise.\n"
"The builtins True and False are the only two instances of the class bool.\n"
"The class bool is a subclass of the class int, and cannot be subclassed."
msgstr ""
"booleano(x) -> lógico\n"
"\n"
"Converte valor para uma variável lógica (verdadeiro/falso).\n"
"\n"
"Quase todos objetos são avaliados como verdadeiros, exceto:\n"
"* O número zero\n"
"* Uma string, lista, conjunto, dicionário ou tupla vazia\n"
"* A constante Nulo"

#. binary.name
msgid "bin"
msgstr "binário"

#. binary.doc
msgid ""
"Return the binary representation of an integer.\n"
"\n"
">>> bin(2796202)\n"
"'0b1010101010101010101010'"
msgstr ""
"Retorna a representação binária de um inteiro.\n"
"\n"
">>> binário(2796202) \n"
"'0b1010101010101010101010'"

#. octal.name
msgid "oct"
msgstr "octal"

#. octal.doc
msgid ""
"Return the octal representation of an integer.\n"
"\n"
">>> oct(342391)\n"
"'0o1234567'"
msgstr ""
"Retorna a representação octal de um inteiro.\n"
"\n"
">>> octal(342391) \n"
"'0o1234567'"

#. hexadecimal.doc
msgid ""
"Return the hexadecimal representation of an integer.\n"
"\n"
">>> hex(12648430)\n"
"'0xc0ffee'"
msgstr ""
"Retorna a representação hexadecimal de um inteiro.\n"
"\n"
">>> hexadecimal(12648430) \n"
"'0xc0ffee'"

#. character.name
msgid "chr"
msgstr "caractere"

#. character.doc
msgid "Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff."
msgstr ""
"Retorna um texto com um único caractere a partir do valor numérico na tabela unicode; \n"
"\n"
"A tabela unicode contêm todos símbolos utilizados em diversas linguagens. O valor de n está na faixa 0 <= n <= 0x10ffff (111411)."

#. enumeration.name
#. enumerate.name
#. inverted.name
msgid "<lambda>"
msgstr "<lambda>"

#. enumeration.args
msgid "x, start"
msgstr "x, começo"

#. length.name
msgid "len"
msgstr "tamanho"

#. length.doc
msgid "Return the number of items in a container."
msgstr "Retorna o número de elementos de um objeto."

#. enumerate.args
#. inverted.args
msgid "x"
msgstr "x"

#. sorted.name
msgid "sorted"
msgstr "ordenado"

#. sorted.doc
msgid ""
"Return a new list containing all items from the iterable in ascending order.\n"
"\n"
"A custom key function can be supplied to customize the sort order, and the\n"
"reverse flag can be set to request the result in descending order."
msgstr ""
"Retornar uma nova lista contendo todos os itens do argumento organizados em ordem crescente.\n"
"\n"
"Uma função opcional pode ser fornecida para personalizar a ordem de classificação."

#. Dictionary.name
msgid "dict"
msgstr "dicionário"

#. Dictionary.doc
#, fuzzy
msgid ""
"dict() -> new empty dictionary\n"
"dict(mapping) -> new dictionary initialized from a mapping object's\n"
"    (key, value) pairs\n"
"dict(iterable) -> new dictionary initialized as if via:\n"
"    d = {}\n"
"    for k, v in iterable:\n"
"        d[k] = v\n"
"dict(**kwargs) -> new dictionary initialized with the name=value pairs\n"
"    in the keyword argument list.  For example:  dict(one=1, two=2)"
msgstr ""
"Dict () -> novo dicionário vazio dict (mapping) -> novo dicionário inicializado a partir de um objeto de mapeamento\n"
"    (Chave, valor) pairs dict (iterable) -> novo dicionário inicializado como se via:\n"
"    D = {}\n"
"    Para k, v em iterável:\n"
"        D [k] = v dict (** kwargs) -> novo dicionário inicializado com os pares nome = valor\n"
"    Na lista de argumentos de palavras-chave. Por exemplo: dict (um = 1, dois = 2)"

#. Dictionary:clear
#. List:clear
msgid "clear"
msgstr "limpar"

#. Dictionary:copy
#. List:copy
msgid "copy"
msgstr "cópia"

#. Dictionary:fromkeys
#, fuzzy
msgid "fromkeys"
msgstr "Das teclas"

#. Dictionary:get
#, fuzzy
msgid "get"
msgstr "obter"

#. Dictionary:items
msgid "items"
msgstr "itens"

#. Dictionary:keys
#, fuzzy
msgid "keys"
msgstr "chaves"

#. Dictionary:pop
#. List:pop
#, fuzzy
msgid "pop"
msgstr "Pop"

#. Dictionary:popitem
#, fuzzy
msgid "popitem"
msgstr "Popitem"

#. Dictionary:setdefault
msgid "setdefault"
msgstr "definir_padrão"

#. Dictionary:update
msgid "update"
msgstr "atualizar"

#. Dictionary:values
#, fuzzy
msgid "values"
msgstr "Valores"

#. Tuple.name
#, fuzzy
msgid "tuple"
msgstr "Tupla"

#. Tuple.doc
#, fuzzy
msgid ""
"tuple() -> empty tuple\n"
"tuple(iterable) -> tuple initialized from iterable's items\n"
"\n"
"If the argument is a tuple, the return value is the same object."
msgstr ""
"Tuple () -> tupla vazia tupla (iterável) -> tupla inicializada a partir de itens iteráveis\n"
"\n"
"Se o argumento for uma tupla, o valor de retorno é o mesmo objeto."

#. Tuple:count
#. List:count
#. String:count
#, fuzzy
msgid "count"
msgstr "contagem"

#. Tuple:index
#. List:index
#. String:index
#, fuzzy
msgid "index"
msgstr "índice"

#. List.name
#, fuzzy
msgid "list"
msgstr "Lista"

#. List.doc
#, fuzzy
msgid ""
"list() -> new empty list\n"
"list(iterable) -> new list initialized from iterable's items"
msgstr "List () -> nova lista de lista vazia (iterável) -> nova lista inicializada a partir de itens de iterable"

#. List:append
#, fuzzy
msgid "append"
msgstr "acrescentar"

#. List:extend
#, fuzzy
msgid "extend"
msgstr "ampliar"

#. List:insert
#, fuzzy
msgid "insert"
msgstr "inserir"

#. List:remove
#, fuzzy
msgid "remove"
msgstr "remover"

#. List:reverse
#, fuzzy
msgid "reverse"
msgstr "marcha ré"

#. List:sort
#, fuzzy
msgid "sort"
msgstr "ordenar"

#. String.name
#, fuzzy
msgid "str"
msgstr "Str"

#. String.doc
#, fuzzy
msgid ""
"str(object='') -> str\n"
"str(bytes_or_buffer[, encoding[, errors]]) -> str\n"
"\n"
"Create a new string object from the given object. If encoding or\n"
"errors is specified, then the object must expose a data buffer\n"
"that will be decoded using the given encoding and error handler.\n"
"Otherwise, returns the result of object.__str__() (if defined)\n"
"or repr(object).\n"
"encoding defaults to sys.getdefaultencoding().\n"
"errors defaults to 'strict'."
msgstr ""
"Str (object = '') -> str str (bytes_or_buffer [, codificação [, erros]]) -> str\n"
"\n"
"Crie um novo objeto de seqüência de caracteres a partir do objeto fornecido. Se codificação ou erros for especificado, o objeto deve expor um buffer de dados que será decodificado usando a codificação e manipulador de erro. Caso contrário, retorna o resultado do objeto .__ str __ () (se definido) ou repr (objeto). A codificação padrão é sys.getdefaultencoding (). Erros padrão é 'estrito'."

#. String:capitalize
#, fuzzy
msgid "capitalize"
msgstr "capitalizar"

#. String:casefold
#, fuzzy
msgid "casefold"
msgstr "Caixa"

#. String:center
#, fuzzy
msgid "center"
msgstr "centro"

#. String:encode
#, fuzzy
msgid "encode"
msgstr "codificar"

#. String:endswith
#, fuzzy
msgid "endswith"
msgstr "termina com"

#. String:expandtabs
#, fuzzy
msgid "expandtabs"
msgstr "Expandida"

#. String:find
msgid "find"
msgstr "encontrar"

#. String:format
msgid "format"
msgstr ""
"formatar\n"
"formate"

#. String:format_map
msgid "format_map"
msgstr ""
"formatar_mapa\n"
"formate_mapa"

#. String:isalnum
#, fuzzy
msgid "isalnum"
msgstr "Isnum"

#. String:isalpha
#, fuzzy
msgid "isalpha"
msgstr "Isalpa"

#. String:isdecimal
#, fuzzy
msgid "isdecimal"
msgstr "Isdcimal"

#. String:isdigit
#, fuzzy
msgid "isdigit"
msgstr "É um dígito"

#. String:isidentifier
#, fuzzy
msgid "isidentifier"
msgstr "Isidentifier"

#. String:islower
#, fuzzy
msgid "islower"
msgstr "é inferior"

#. String:isnumeric
msgid "isnumeric"
msgstr "é_numérico"

#. String:isprintable
#, fuzzy
msgid "isprintable"
msgstr "É imprimível"

#. String:isspace
#, fuzzy
msgid "isspace"
msgstr "Isspace"

#. String:istitle
#, fuzzy
msgid "istitle"
msgstr "É legítimo"

#. String:isupper
#, fuzzy
msgid "isupper"
msgstr "É melhor"

#. String:ljust
#, fuzzy
msgid "ljust"
msgstr "Apenas"

#. String:lower
#, fuzzy
msgid "lower"
msgstr "mais baixo"

#. String:lstrip
#, fuzzy
msgid "lstrip"
msgstr "Lstrip"

#. String:maketrans
#, fuzzy
msgid "maketrans"
msgstr "Maketrans"

#. String:partition
#, fuzzy
msgid "partition"
msgstr "Partição"

#. String:replace
#, fuzzy
msgid "replace"
msgstr "substituir"

#. String:rfind
#, fuzzy
msgid "rfind"
msgstr "Rfind"

#. String:rindex
#, fuzzy
msgid "rindex"
msgstr "Rindex"

#. String:rjust
#, fuzzy
msgid "rjust"
msgstr "Apenas"

#. String:rpartition
#, fuzzy
msgid "rpartition"
msgstr "Repartição"

#. String:rsplit
#, fuzzy
msgid "rsplit"
msgstr "Rsplit"

#. String:rstrip
#, fuzzy
msgid "rstrip"
msgstr "Rstrip"

#. String:split
msgid "split"
msgstr "dividir"

#. String:splitlines
#, fuzzy
msgid "splitlines"
msgstr "Linhas de divisão"

#. String:startswith
msgid "startswith"
msgstr "começa_com"

#. String:strip
#, fuzzy
msgid "strip"
msgstr "faixa"

#. String:swapcase
#, fuzzy
msgid "swapcase"
msgstr "Swapcase"

#. String:title
#, fuzzy
msgid "title"
msgstr "título"

#. String:translate
#, fuzzy
msgid "translate"
msgstr "traduzir"

#. String:upper
msgid "upper"
msgstr ""

#. String:zfill
#, fuzzy
msgid "zfill"
msgstr "Zfill"

#. type.name
msgid "type"
msgstr "tipo"

#. type.doc
msgid ""
"type(object_or_name, bases, dict)\n"
"type(object) -> the object's type\n"
"type(name, bases, dict) -> a new type"
msgstr "Tipo (object_or_name, bases, dict) tipo (objeto) -> tipo de objeto tipo (nome, bases, dict) -> um novo tip"

#. type:mro
msgid "mro"
msgstr "mro"

#. help.doc
#, fuzzy
msgid ""
"Define the builtin 'help'.\n"
"\n"
"This is a wrapper around pydoc.help that provides a helpful message\n"
"when 'help' is typed at the Python interactive prompt.\n"
"\n"
"Calling help() at the Python prompt starts an interactive help session.\n"
"Calling help(thing) prints help for the python object 'thing'."
msgstr ""
"Defina a 'ajuda' integrada.\n"
"\n"
"Este é um wrapper em torno de pydoc.help que fornece uma mensagem útil quando 'help' é digitado no prompt interativo do Python.\n"
"\n"
"Chamar help () no prompt Python inicia uma sessão de ajuda interativa. Chamando ajuda (coisa) imprime ajuda para o objeto python 'coisa'."

#. nulo
#, fuzzy
msgid "nulo"
msgstr "Nulo"

#. Nulo
#, fuzzy
msgid "Nulo"
msgstr "Nulo"
